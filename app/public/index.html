<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>app-web</title>
    <style>
        html,
        body {
            margin: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #050505;
            overscroll-behavior: none;
        }

        body {
            position: fixed;
            inset: 0;
            font-family: "Segoe UI", sans-serif;
        }

        #display {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #050505;
        }

        #display canvas {
            display: block;
            max-width: 100%;
            max-height: 100%;
            outline: none;
            background: #050505;
        }

        #hud {
            position: fixed;
            top: 12px;
            right: 12px;
            z-index: 20;
            display: grid;
            gap: 8px;
            justify-items: end;
        }

        .hud-panel {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            border-radius: 999px;
            background: rgba(10, 12, 16, 0.74);
            color: #f5f7fa;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 26px rgba(0, 0, 0, 0.28);
        }

        #status {
            white-space: nowrap;
            transition: opacity 180ms ease;
        }

        #status.is-hidden {
            opacity: 0;
        }

        .toggle {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
            font-size: 12px;
            color: #d9dde3;
        }

        .toggle input {
            margin: 0;
        }

        #closeAppButton {
            border: none;
            border-radius: 999px;
            padding: 8px 12px;
            background: rgba(255, 99, 71, 0.92);
            color: white;
            cursor: pointer;
        }

        #closeAppButton:hover {
            background: rgba(255, 112, 84, 0.98);
        }
    </style>
</head>
<body>
    <div id="display"></div>
    <div id="hud">
        <div class="hud-panel">
            <div id="status">Loading</div>
        </div>
        <div class="hud-panel">
            <label class="toggle"><input id="closeOnUnload" type="checkbox">Close app with tab</label>
            <label class="toggle"><input id="confirmOnClose" type="checkbox">Warn on close</label>
            <button id="closeAppButton" type="button">Close app</button>
        </div>
    </div>

    <script type="module" crossorigin="anonymous">
        import RFB from './core/rfb.js';

        let rfb;
        let desktopName = "";
        let reconnectTimer = 0;
        let resizeTimer = 0;
        let resizeInFlight = false;
        let pendingResize = null;
        let lastResizeSent = "";
        let suppressCloseOnUnload = false;
        let sessionClosing = false;

        const display = document.getElementById("display");
        const statusElement = document.getElementById("status");
        const closeOnUnloadInput = document.getElementById("closeOnUnload");
        const confirmOnCloseInput = document.getElementById("confirmOnClose");
        const closeAppButton = document.getElementById("closeAppButton");
        const sessionMatch = window.location.pathname.match(/^\/sessions\/([a-z0-9]+)/);
        const sessionId = sessionMatch ? sessionMatch[1] : "";
        const sessionToken = new URL(window.location.href).searchParams.get("token") || "";
        const closeOnUnloadKey = "appWeb.closeOnUnload";
        const confirmOnCloseKey = "appWeb.confirmOnClose";

        closeOnUnloadInput.checked = localStorage.getItem(closeOnUnloadKey) !== "0";
        confirmOnCloseInput.checked = localStorage.getItem(confirmOnCloseKey) !== "0";

        closeOnUnloadInput.addEventListener("change", () => {
            localStorage.setItem(closeOnUnloadKey, closeOnUnloadInput.checked ? "1" : "0");
        });

        confirmOnCloseInput.addEventListener("change", () => {
            localStorage.setItem(confirmOnCloseKey, confirmOnCloseInput.checked ? "1" : "0");
        });

        function setStatus(text, autoHide = false) {
            statusElement.textContent = text;
            statusElement.classList.remove("is-hidden");
            if (reconnectTimer) {
                clearTimeout(reconnectTimer);
                reconnectTimer = 0;
            }
            if (autoHide) {
                reconnectTimer = window.setTimeout(() => {
                    statusElement.classList.add("is-hidden");
                }, 1400);
            }
        }

        function readQueryVariable(name, defaultValue) {
            const re = new RegExp('.*[?&]' + name + '=([^&#]*)');
            const match = document.location.href.match(re);
            if (match) {
                return decodeURIComponent(match[1]);
            }
            return defaultValue;
        }

        function readBooleanQuery(name, defaultValue) {
            const fallback = defaultValue ? "1" : "0";
            const value = String(readQueryVariable(name, fallback)).trim().toLowerCase();
            return !["0", "false", "no", "off", ""].includes(value);
        }

        function readNumberQuery(name, defaultValue) {
            const parsed = Number.parseInt(readQueryVariable(name, String(defaultValue)), 10);
            return Number.isFinite(parsed) ? parsed : defaultValue;
        }

        function defaultWebsockifyPath() {
            const pathname = window.location.pathname.replace(/\/+$/, "");
            if (pathname === "") {
                return "websockify";
            }
            return pathname.replace(/^\//, "") + "/websockify";
        }

        function sessionControlUrl(action, params = {}) {
            const url = new URL(`/api/session-control/${sessionId}/${action}`, window.location.origin);
            if (sessionToken) {
                url.searchParams.set("token", sessionToken);
            }
            for (const [key, value] of Object.entries(params)) {
                if (value !== undefined && value !== null && value !== "") {
                    url.searchParams.set(key, String(value));
                }
            }
            return url;
        }

        function focusCanvas() {
            const canvas = document.querySelector("#display canvas");
            if (canvas) {
                canvas.tabIndex = 0;
                canvas.focus({ preventScroll: true });
            }
        }

        function reconnectSoon() {
            suppressCloseOnUnload = true;
            window.setTimeout(() => {
                window.location.reload();
            }, readNumberQuery("reconnect_delay", 1000));
        }

        async function closeSession(reason, keepalive = false) {
            if (!sessionId || sessionClosing) {
                return;
            }
            sessionClosing = true;
            try {
                await fetch(sessionControlUrl("close", { reason }), {
                    method: "POST",
                    keepalive,
                    credentials: "same-origin",
                });
            } catch {
                // best effort on unload
            }
        }

        async function sendResize(width, height) {
            if (!sessionId) {
                return;
            }
            const key = `${width}x${height}`;
            if (key === lastResizeSent) {
                return;
            }
            await fetch(sessionControlUrl("resize", { width, height }), {
                method: "POST",
                credentials: "same-origin",
            });
            lastResizeSent = key;
        }

        function flushPendingResize() {
            if (!pendingResize) {
                return;
            }
            const next = pendingResize;
            pendingResize = null;
            queueSessionResize(next.width, next.height, true);
        }

        function queueSessionResize(width = Math.round(window.innerWidth), height = Math.round(window.innerHeight), immediate = false) {
            const nextWidth = Math.max(640, width);
            const nextHeight = Math.max(360, height);

            if (resizeTimer) {
                clearTimeout(resizeTimer);
                resizeTimer = 0;
            }

            const runner = async () => {
                if (resizeInFlight) {
                    pendingResize = { width: nextWidth, height: nextHeight };
                    return;
                }
                resizeInFlight = true;
                try {
                    await sendResize(nextWidth, nextHeight);
                } catch {
                    // ignore transient resize failures while the session is starting
                } finally {
                    resizeInFlight = false;
                    flushPendingResize();
                }
            };

            if (immediate) {
                runner();
                return;
            }

            resizeTimer = window.setTimeout(runner, 140);
        }

        function connectedToServer() {
            const label = desktopName ? `Connected to ${desktopName}` : "Connected";
            setStatus(label, true);
            focusCanvas();
            queueSessionResize(undefined, undefined, true);
            window.setTimeout(() => queueSessionResize(), 300);
            window.setTimeout(() => queueSessionResize(), 1000);
        }

        function disconnectedFromServer() {
            setStatus("Connection lost. Reconnecting...");
            reconnectSoon();
        }

        function credentialsAreRequired() {
            const password = prompt("Password Required:");
            rfb.sendCredentials({ password });
        }

        function updateDesktopName(e) {
            desktopName = e.detail.name || "";
            document.title = desktopName || readQueryVariable("title", "app-web");
        }

        closeAppButton.addEventListener("click", async () => {
            suppressCloseOnUnload = true;
            setStatus("Closing app...");
            await closeSession("manual_close");
            window.location.replace("/");
        });

        window.addEventListener("resize", () => {
            focusCanvas();
            queueSessionResize();
        }, { passive: true });

        window.addEventListener("orientationchange", () => {
            queueSessionResize();
        });

        window.addEventListener("beforeunload", (event) => {
            if (suppressCloseOnUnload) {
                return;
            }
            if (confirmOnCloseInput.checked) {
                event.preventDefault();
                event.returnValue = "";
            }
        });

        window.addEventListener("pagehide", () => {
            if (suppressCloseOnUnload || !closeOnUnloadInput.checked) {
                return;
            }
            closeSession("tab_close", true);
        });

        window.addEventListener("error", () => {
            reconnectSoon();
        }, true);

        const host = readQueryVariable("host", window.location.hostname);
        const port = readQueryVariable("port", window.location.port);
        const password = readQueryVariable("password");
        const path = readQueryVariable("path", defaultWebsockifyPath());

        let url = window.location.protocol === "https:" ? "wss" : "ws";
        url += "://" + host;
        if (port) {
            url += ":" + port;
        }
        url += "/" + path;

        setStatus("Connecting...");
        rfb = new RFB(display, url, { credentials: { password } });

        rfb.addEventListener("connect", connectedToServer);
        rfb.addEventListener("disconnect", disconnectedFromServer);
        rfb.addEventListener("credentialsrequired", credentialsAreRequired);
        rfb.addEventListener("desktopname", updateDesktopName);

        rfb.viewOnly = readBooleanQuery("view_only", false);
        rfb.scaleViewport = readBooleanQuery("scale", true);
        rfb.clipViewport = readBooleanQuery("clip", false);
        rfb.resizeSession = false;
        rfb.qualityLevel = readNumberQuery("quality", 9);
        rfb.compressionLevel = readNumberQuery("compression", 1);
        rfb.showDotCursor = true;
        rfb.dragViewport = false;
        rfb.focusOnClick = true;
        document.title = readQueryVariable("title", "app-web");

        focusCanvas();
        window.setInterval(focusCanvas, 250);
    </script>
</body>
</html>
